# Multi-threaded external sorting
## Outline
Goal of this project is making sorting program for 1, 2, 4GB data generated by gensort on 2GB ram, and implementing more faster program.
## My blueprint
First, I create 32 threads and read data part dividing by number of threads and sort each part. At this time, max capacity of data array is 1GB. So I read 1GB of data and sort it.
Second, I merge 32 parts by priority queue and write to disc. At this time, part of the sorted data is left in memory. So I reduce file I/O.  
Last, I merge sorted temporary data file. At this merging, I just use loop, instead of priority queue, because number of temporary file is four at most.
## Specific implentation
### My function

    struct Tup;
To sort 100byte data by std::sort, I need type casting and this struct is for that. 

    int compare(cosnt void *p1, const void *p2);
    int compare_sort(const Tup &a, const Tup &b);
Function to compare with two data, first is made for just compare, the other is made for std::sort. Both functions perform comparing the preceding 10bytes by one by one.

    int file_read(int fd, char *buf, size_t size, size_t start);
    int file_write(int fd, char *buf, size_t size, size_t start);
Function wrapping for pread, pwrite. Argument fd is file descriptor, buf is array to save data, size is size of data, and start is start offset of data file.

    void worker(const char *path, char *buf, size_t size, int index);
Function that work for each thread. This function perform that read a patition of data file and sort it and save it to buf. Argument path is path of file, size is size to read, index is start offset of file to read.

    class Myheap;
Priority queue for split data. 

### in main
I sort 1GB data at once, so allocate 1GB memory for that, and write buffer size is 10MB. Divide 1GB by number of threads(32), and sort it in each thread. And merge it. I write this sorted file to disc, but not all, just part of it. Because of saving memory.  
When sorting and merging is over, I need to merge sorted files. Before I enter this part, I remain part of data for saving memory, I use this data at beginning. And I use all data of each part in memory, I read more data until end of data file. I use a flag to tell if I have finished reading the file. I write merged data to disc when write buffer is full. When all work is over, I close all file descriptor, delete allocated memory.